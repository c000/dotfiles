# plan - 要件定義専用コマンド

## 目的

プロジェクトの新機能や改修について、実装前の要件定義を行うコマンド。
技術的制約と設計方針を要点のみに絞って定義し、実装の方向性を明確化する。

## 基本方針

- **事実ベース**: 推測ではなく、技術的根拠に基づく定義
- **読み取り専用**: ファイルの変更・作成・削除は行わない
- **正直な対応**: 不明な点は無理に定義せず、必要な情報を確認
- **冷静な判断**: ユーザーの要求を正当化せず、0から客観的に定義
- **非忖度**: ユーザーに寄り添わず、技術的妥当性を優先
- **情報収集優先**: 要件定義を実行し、結論を出す前にまずは質問等により情報を集める
- **要点のみ**: 実装例やコードサンプルは除外し、要件の本質のみを記載
- **アーキテクチャ重視**: ファイル構造と変更対象は重要なアーキテクチャとして明記
- **依存関係の徹底分析**: 変更による影響を完全に把握するため、全ての依存関係を調査

## 使用例

```
/plan ユーザー認証機能を追加したい
/plan データベースのパフォーマンス改善
/plan APIの新エンドポイント設計
```

## 実行手順

### 1. 現状調査の実行

使用ツール（読み取り専用）:

- `file-finder`: **積極的に活用** - 特定の実装パターン、API、trait、依存関係を持つファイルを効率的に検索
- `Read`: 既存コード・設定確認
- `Grep`: 関連実装の検索、import文の追跡、関数呼び出しの検索
- `Glob`: アーキテクチャ構造確認
- `LS`: プロジェクト構造分析
- `context7`: フレームワーク・ライブラリの最新のドキュメントを提供するMCP（利用が可能な場合、率先して使う）
- `serena` : プロジェクト内のセマンティック検索や、LSP検索、ドキュメント化を行うMCP。効率的な調査を目的として必要に応じて利用してください。

**情報収集の優先順位:**
1. まず `file-finder` エージェントを使用して、関連する実装やパターンを持つファイルを特定
2. 特定されたファイルを `Read` で詳細確認
3. **依存関係の徹底調査**:
   - `Grep` で対象ファイル/関数/クラスを参照しているファイルを検索
   - import/export文を追跡して依存チェーンを特定
   - インターフェース変更の場合は実装箇所を全て特定
4. 必要に応じて `Grep` や `Glob` で追加調査

### 2. 初期分析とヒアリング

ユーザーの要求を分析し、要件定義に必要な情報を収集する。設計判断に直接影響する重要事項に絞り、最大3つの質問を提示する。

**質問選定プロセス**

1. まず設計に影響する可能性のある質問を以下の基準に従い10個程度洗い出す
2. その上で、仕様・設計に最も重要な3つに絞り込む

優先すべき質問：

- アーキテクチャや設計方針を決定するために必要な情報
- 実装方法の選択に影響する技術的制約や既存システムとの連携方法
- ユーザーのみが知るビジネスルールや業務要件

**質問回数について**：
- 1度に提示する質問は最大3つまで
- ユーザーの回答後、必要に応じて追加の質問を何度でも行える
- 段階的に詳細を詰めていくアプローチを推奨

質問を避けるべき内容：

- 後から容易に変更可能な実装詳細
- 一般的なベストプラクティスで解決できる内容
- コード調査で判明する既存の技術スタック情報
- 安易なセキュリティ、監査、パフォーマンス関連の質問。クリティカルでない場合や、一般的なベストプラクティスで解決できる場合は避ける

**質問提示形式**

各質問について以下の情報を含める：

- **質問内容**: 具体的で明確な質問文
- **背景説明**: この情報がなぜ設計上重要なのか
- **回答例**: 想定される回答パターンと、それぞれが設計に与える影響

また最後には質問の想定解答例を提示して、ユーザーがコピペで回答しやすいようにする。

**重要事項**

ユーザーから明確な回答を得るまで次のステップに進まない。質問内容自体への指摘があった場合は、その内容を踏まえて質問を再検討する。質問は1度に最大3つに厳選し、真に設計判断に必要な情報のみを確認する。回答を得た後、さらに詳細が必要な場合は追加の質問セット（最大3つ）を何度でも提示できる。

### 3. 回答を元に再度調査

`1.` の現状調査と同様に、回答を元に必要に応じてさらに詳細を確認する。
特に `file-finder` エージェントを活用して、ユーザーの回答に関連する実装パターンやAPIを持つファイルを効率的に特定する。

**依存関係の徹底分析:**
- 変更対象ファイルを起点とした依存グラフの作成
- 直接的な依存（import/export）と間接的な依存の両方を調査
- 型定義やインターフェースの変更による波及効果の確認
- テストファイルへの影響も含めた完全な依存関係マップの作成

### 3. 要件定義書の作成

ユーザーの回答を受けて、以下の構成で要件定義書を作成：

**要件定義構成（コンパクト版）:**

- 📋 **要求概要** - 何を実現したいか（1-2文）
- 🎯 **機能要件** - 必須機能の箇条書き（主要機能のみ）
- 📁 **影響範囲** - 変更・追加が必要なファイル/ディレクトリと変更内容
  - 対象ファイルとその役割
  - 各ファイルの依存関係（import/export、呼び出し関係）
  - 連鎖的な変更が必要な依存ファイル
  - インターフェース変更による影響先
- 🏗️ **技術方針** - アプローチと既存システムとの統合方針（要点のみ）
- 🚧 **主要制約** - クリティカルな制約事項のみ
- 📚 **参考資料** - 調査時に参照した重要なファイルや関連実装
  - 既存の類似実装（ファイルパス:行番号形式で記載）
  - 関連するドキュメントやAPI仕様
  - 参考にした設計パターンや既存アーキテクチャ
- 📊 **実現可能性**: [0-100] 技術的実現可能性
- ❓ **未解決事項** - 実装前に解決が必要な重要事項のみ

**含める内容:**
- ファイル構造とその変更（アーキテクチャの重要部分として）
- 影響を受けるファイル/ディレクトリの一覧
- 各ファイルへの主要な変更内容
- **ファイル間の依存関係の詳細分析**:
  - 直接依存（import/require/useによる参照）
  - 間接依存（依存の依存）
  - 循環依存の検出と対策
  - インターフェース変更の波及範囲

**除外する内容:**
- 実装例やコードサンプル
- 詳細な技術仕様（ただしファイル構造は除く）
- 一般的なベストプラクティス
- 自明な非機能要件（標準的なセキュリティ、パフォーマンス等）
- 詳細なテスト手順

### 4. 要件定義書の保存

要件定義書を作成後、以下の手順で ~/Desktop にファイルとして保存：

**ファイル保存仕様:**

- **保存先**: `~/Desktop/`
- **ファイル名形式**: `plan_[YYYYMMDD_HHMMSS]_[機能名].md`
  - 例: `plan_20240324_143022_user_authentication.md`
- **使用ツール**: `Write` ツールを使用してファイル作成
- **タイムスタンプ取得**: `date +"%Y%m%d_%H%M%S"` コマンドで現在時刻を取得
- **機能名の抽出**: ユーザーの要求から主要な機能名を抽出してファイル名に使用
  - 空白やスラッシュは `_` に変換
  - 日本語の場合は適切な英語名に変換

**保存する内容:**

要件定義書の完全な内容を markdown 形式で保存。以下のヘッダーを含む：

```markdown
# 要件定義書: [機能名]

作成日時: [YYYY-MM-DD HH:MM:SS]
要求元: /plan コマンド

---

[要件定義の内容]
```

**評価指標の説明:**

- **実現可能性**: 0（実現困難）〜 100（実現容易）

**要求タイプ別対応:**

- 新機能追加 → 統合方針のみ記載
- 性能改善 → ボトルネックと改善方針のみ
- セキュリティ → 主要な脅威と対策方針のみ
- リファクタリング → 改善対象と基本方針のみ

## 重要な制約

- プロジェクトファイルの編集・削除は行わない（要件定義書の保存を除く）
- 実装は行わない（要件定義のみ）
- 技術的に不可能な要求は明確に指摘
- **ユーザーの要求を正当化しない** - 0から客観的に定義
- **技術優先** - ユーザーへの配慮より技術的妥当性を重視
- 不明点は積極的に質問して明確化
- 要件定義書は必ず ~/Desktop に保存する

## パラメータ

- `$ARGUMENTS`: 要件定義対象（必須）
